{-
   CRDOpenAPI

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   CRDOpenAPI API version: v1.15.2
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Operator.Helm.OpenAPI.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Operator.Helm.OpenAPI.Model (module Operator.Helm.OpenAPI.Model, module Operator.Helm.OpenAPI.ImportMappings) where

import Kubernetes.OpenAPI.Core
import Kubernetes.OpenAPI.MimeTypes
import Kubernetes.OpenAPI.Model
import Operator.Helm.OpenAPI.ImportMappings

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Models


-- ** V1HelmRelease
-- | V1HelmRelease
data V1HelmRelease = V1HelmRelease
  { v1HelmReleaseApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , v1HelmReleaseKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , v1HelmReleaseMetadata :: !(Maybe V1ObjectMeta) -- ^ "metadata"
  , v1HelmReleaseSpec :: !(Maybe V1HelmReleaseSpec) -- ^ "spec"
  , v1HelmReleaseStatus :: !(Maybe V1HelmReleaseStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmRelease
instance A.FromJSON V1HelmRelease where
  parseJSON = A.withObject "V1HelmRelease" $ \o ->
    V1HelmRelease
      <$> (o .:? "apiVersion")
      <*> (o .:? "kind")
      <*> (o .:? "metadata")
      <*> (o .:? "spec")
      <*> (o .:? "status")

-- | ToJSON V1HelmRelease
instance A.ToJSON V1HelmRelease where
  toJSON V1HelmRelease {..} =
   _omitNulls
      [ "apiVersion" .= v1HelmReleaseApiVersion
      , "kind" .= v1HelmReleaseKind
      , "metadata" .= v1HelmReleaseMetadata
      , "spec" .= v1HelmReleaseSpec
      , "status" .= v1HelmReleaseStatus
      ]


-- | Construct a value of type 'V1HelmRelease' (by applying it's required fields, if any)
mkV1HelmRelease
  :: V1HelmRelease
mkV1HelmRelease =
  V1HelmRelease
  { v1HelmReleaseApiVersion = Nothing
  , v1HelmReleaseKind = Nothing
  , v1HelmReleaseMetadata = Nothing
  , v1HelmReleaseSpec = Nothing
  , v1HelmReleaseStatus = Nothing
  }

-- ** V1HelmReleaseList
-- | V1HelmReleaseList
-- HelmReleaseList is a list of HelmRelease
data V1HelmReleaseList = V1HelmReleaseList
  { v1HelmReleaseListApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , v1HelmReleaseListItems :: !([V1HelmRelease]) -- ^ /Required/ "items" - List of helmreleases. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md
  , v1HelmReleaseListKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , v1HelmReleaseListMetadata :: !(Maybe V1HelmReleaseListMetadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseList
instance A.FromJSON V1HelmReleaseList where
  parseJSON = A.withObject "V1HelmReleaseList" $ \o ->
    V1HelmReleaseList
      <$> (o .:? "apiVersion")
      <*> (o .:  "items")
      <*> (o .:? "kind")
      <*> (o .:? "metadata")

-- | ToJSON V1HelmReleaseList
instance A.ToJSON V1HelmReleaseList where
  toJSON V1HelmReleaseList {..} =
   _omitNulls
      [ "apiVersion" .= v1HelmReleaseListApiVersion
      , "items" .= v1HelmReleaseListItems
      , "kind" .= v1HelmReleaseListKind
      , "metadata" .= v1HelmReleaseListMetadata
      ]


-- | Construct a value of type 'V1HelmReleaseList' (by applying it's required fields, if any)
mkV1HelmReleaseList
  :: [V1HelmRelease] -- ^ 'v1HelmReleaseListItems': List of helmreleases. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md
  -> V1HelmReleaseList
mkV1HelmReleaseList v1HelmReleaseListItems =
  V1HelmReleaseList
  { v1HelmReleaseListApiVersion = Nothing
  , v1HelmReleaseListItems
  , v1HelmReleaseListKind = Nothing
  , v1HelmReleaseListMetadata = Nothing
  }

-- ** V1HelmReleaseListMetadata
-- | V1HelmReleaseListMetadata
-- ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
data V1HelmReleaseListMetadata = V1HelmReleaseListMetadata
  { v1HelmReleaseListMetadataContinue :: !(Maybe Text) -- ^ "continue" - continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
  , v1HelmReleaseListMetadataRemainingItemCount :: !(Maybe Integer) -- ^ "remainingItemCount" - remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.  This field is alpha and can be changed or removed without notice.
  , v1HelmReleaseListMetadataResourceVersion :: !(Maybe Text) -- ^ "resourceVersion" - String that identifies the server&#39;s internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
  , v1HelmReleaseListMetadataSelfLink :: !(Maybe Text) -- ^ "selfLink" - selfLink is a URL representing this object. Populated by the system. Read-only.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseListMetadata
instance A.FromJSON V1HelmReleaseListMetadata where
  parseJSON = A.withObject "V1HelmReleaseListMetadata" $ \o ->
    V1HelmReleaseListMetadata
      <$> (o .:? "continue")
      <*> (o .:? "remainingItemCount")
      <*> (o .:? "resourceVersion")
      <*> (o .:? "selfLink")

-- | ToJSON V1HelmReleaseListMetadata
instance A.ToJSON V1HelmReleaseListMetadata where
  toJSON V1HelmReleaseListMetadata {..} =
   _omitNulls
      [ "continue" .= v1HelmReleaseListMetadataContinue
      , "remainingItemCount" .= v1HelmReleaseListMetadataRemainingItemCount
      , "resourceVersion" .= v1HelmReleaseListMetadataResourceVersion
      , "selfLink" .= v1HelmReleaseListMetadataSelfLink
      ]


-- | Construct a value of type 'V1HelmReleaseListMetadata' (by applying it's required fields, if any)
mkV1HelmReleaseListMetadata
  :: V1HelmReleaseListMetadata
mkV1HelmReleaseListMetadata =
  V1HelmReleaseListMetadata
  { v1HelmReleaseListMetadataContinue = Nothing
  , v1HelmReleaseListMetadataRemainingItemCount = Nothing
  , v1HelmReleaseListMetadataResourceVersion = Nothing
  , v1HelmReleaseListMetadataSelfLink = Nothing
  }

-- ** V1HelmReleaseSpec
-- | V1HelmReleaseSpec
data V1HelmReleaseSpec = V1HelmReleaseSpec
  { v1HelmReleaseSpecChart :: !(V1HelmReleaseSpecChart) -- ^ /Required/ "chart"
  , v1HelmReleaseSpecDisableOpenApiValidation :: !(Maybe Bool) -- ^ "disableOpenAPIValidation" - DisableOpenAPIValidation controls whether OpenAPI validation is enforced.
  , v1HelmReleaseSpecForceUpgrade :: !(Maybe Bool) -- ^ "forceUpgrade" - Force will mark this Helm release to &#x60;--force&#x60; upgrades. This forces the resource updates through delete/recreate if needed.
  , v1HelmReleaseSpecHelmVersion :: !(Maybe E'HelmVersion) -- ^ "helmVersion" - HelmVersion is the version of Helm to target. If not supplied, the lowest _enabled Helm version_ will be targeted. Valid HelmVersion values are: \&quot;v2\&quot;, \&quot;v3\&quot;
  , v1HelmReleaseSpecMaxHistory :: !(Maybe Int) -- ^ "maxHistory" - MaxHistory is the maximum amount of revisions to keep for the Helm release. If not supplied, it defaults to 10.
  , v1HelmReleaseSpecReleaseName :: !(Maybe Text) -- ^ "releaseName" - ReleaseName is the name of the The Helm release. If not supplied, it will be generated by affixing the namespace to the resource name.
  , v1HelmReleaseSpecResetValues :: !(Maybe Bool) -- ^ "resetValues" - ResetValues will mark this Helm release to reset the values to the defaults of the targeted chart before performing an upgrade. Not explicitly setting this to &#x60;false&#x60; equals to &#x60;true&#x60; due to the declarative nature of the operator.
  , v1HelmReleaseSpecRollback :: !(Maybe V1HelmReleaseSpecRollback) -- ^ "rollback"
  , v1HelmReleaseSpecSkipCrDs :: !(Maybe Bool) -- ^ "skipCRDs" - SkipCRDs will mark this Helm release to skip the creation of CRDs during a Helm 3 installation.
  , v1HelmReleaseSpecTargetNamespace :: !(Maybe Text) -- ^ "targetNamespace" - TargetNamespace overrides the targeted namespace for the Helm release. The default namespace equals to the namespace of the HelmRelease resource.
  , v1HelmReleaseSpecTest :: !(Maybe V1HelmReleaseSpecTest) -- ^ "test"
  , v1HelmReleaseSpecTimeout :: !(Maybe Integer) -- ^ "timeout" - Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during installation and upgrade operations.
  , v1HelmReleaseSpecValueFileSecrets :: !(Maybe [V1HelmReleaseSpecValueFileSecrets]) -- ^ "valueFileSecrets" - ValueFileSecrets holds the local name references to secrets. DEPRECATED, use ValuesFrom.secretKeyRef instead.
  , v1HelmReleaseSpecValues :: !(Maybe A.Value) -- ^ "values" - Values holds the values for this Helm release.
  , v1HelmReleaseSpecValuesFrom :: !(Maybe [V1HelmReleaseSpecValuesFrom]) -- ^ "valuesFrom"
  , v1HelmReleaseSpecWait :: !(Maybe Bool) -- ^ "wait" - Wait will mark this Helm release to wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpec
instance A.FromJSON V1HelmReleaseSpec where
  parseJSON = A.withObject "V1HelmReleaseSpec" $ \o ->
    V1HelmReleaseSpec
      <$> (o .:  "chart")
      <*> (o .:? "disableOpenAPIValidation")
      <*> (o .:? "forceUpgrade")
      <*> (o .:? "helmVersion")
      <*> (o .:? "maxHistory")
      <*> (o .:? "releaseName")
      <*> (o .:? "resetValues")
      <*> (o .:? "rollback")
      <*> (o .:? "skipCRDs")
      <*> (o .:? "targetNamespace")
      <*> (o .:? "test")
      <*> (o .:? "timeout")
      <*> (o .:? "valueFileSecrets")
      <*> (o .:? "values")
      <*> (o .:? "valuesFrom")
      <*> (o .:? "wait")

-- | ToJSON V1HelmReleaseSpec
instance A.ToJSON V1HelmReleaseSpec where
  toJSON V1HelmReleaseSpec {..} =
   _omitNulls
      [ "chart" .= v1HelmReleaseSpecChart
      , "disableOpenAPIValidation" .= v1HelmReleaseSpecDisableOpenApiValidation
      , "forceUpgrade" .= v1HelmReleaseSpecForceUpgrade
      , "helmVersion" .= v1HelmReleaseSpecHelmVersion
      , "maxHistory" .= v1HelmReleaseSpecMaxHistory
      , "releaseName" .= v1HelmReleaseSpecReleaseName
      , "resetValues" .= v1HelmReleaseSpecResetValues
      , "rollback" .= v1HelmReleaseSpecRollback
      , "skipCRDs" .= v1HelmReleaseSpecSkipCrDs
      , "targetNamespace" .= v1HelmReleaseSpecTargetNamespace
      , "test" .= v1HelmReleaseSpecTest
      , "timeout" .= v1HelmReleaseSpecTimeout
      , "valueFileSecrets" .= v1HelmReleaseSpecValueFileSecrets
      , "values" .= v1HelmReleaseSpecValues
      , "valuesFrom" .= v1HelmReleaseSpecValuesFrom
      , "wait" .= v1HelmReleaseSpecWait
      ]


-- | Construct a value of type 'V1HelmReleaseSpec' (by applying it's required fields, if any)
mkV1HelmReleaseSpec
  :: V1HelmReleaseSpecChart -- ^ 'v1HelmReleaseSpecChart' 
  -> V1HelmReleaseSpec
mkV1HelmReleaseSpec v1HelmReleaseSpecChart =
  V1HelmReleaseSpec
  { v1HelmReleaseSpecChart
  , v1HelmReleaseSpecDisableOpenApiValidation = Nothing
  , v1HelmReleaseSpecForceUpgrade = Nothing
  , v1HelmReleaseSpecHelmVersion = Nothing
  , v1HelmReleaseSpecMaxHistory = Nothing
  , v1HelmReleaseSpecReleaseName = Nothing
  , v1HelmReleaseSpecResetValues = Nothing
  , v1HelmReleaseSpecRollback = Nothing
  , v1HelmReleaseSpecSkipCrDs = Nothing
  , v1HelmReleaseSpecTargetNamespace = Nothing
  , v1HelmReleaseSpecTest = Nothing
  , v1HelmReleaseSpecTimeout = Nothing
  , v1HelmReleaseSpecValueFileSecrets = Nothing
  , v1HelmReleaseSpecValues = Nothing
  , v1HelmReleaseSpecValuesFrom = Nothing
  , v1HelmReleaseSpecWait = Nothing
  }

-- ** V1HelmReleaseSpecChart
-- | V1HelmReleaseSpecChart
data V1HelmReleaseSpecChart = V1HelmReleaseSpecChart
  { v1HelmReleaseSpecChartChartPullSecret :: !(Maybe V1HelmReleaseSpecChartChartPullSecret) -- ^ "chartPullSecret"
  , v1HelmReleaseSpecChartGit :: !(Maybe Text) -- ^ "git" - Git URL is the URL of the Git repository, e.g. &#x60;git@github.com:org/repo&#x60;, &#x60;http://github.com/org/repo&#x60;, or &#x60;ssh://git@example.com:2222/org/repo.git&#x60;.
  , v1HelmReleaseSpecChartName :: !(Maybe Text) -- ^ "name" - Name is the name of the Helm chart _without_ an alias, e.g. redis (for &#x60;helm upgrade [flags] stable/redis&#x60;).
  , v1HelmReleaseSpecChartPath :: !(Maybe Text) -- ^ "path" - Path is the path to the chart relative to the repository root.
  , v1HelmReleaseSpecChartRef :: !(Maybe Text) -- ^ "ref" - Ref is the Git branch (or other reference) to use. Defaults to &#39;master&#39;, or the configured default Git ref.
  , v1HelmReleaseSpecChartRepository :: !(Maybe Text) -- ^ "repository" - RepoURL is the URL of the Helm repository, e.g. &#x60;https://kubernetes-charts.storage.googleapis.com&#x60; or &#x60;https://charts.example.com&#x60;.
  , v1HelmReleaseSpecChartSecretRef :: !(Maybe V1HelmReleaseSpecChartSecretRef) -- ^ "secretRef"
  , v1HelmReleaseSpecChartSkipDepUpdate :: !(Maybe Bool) -- ^ "skipDepUpdate" - SkipDepUpdate will tell the operator to skip running &#39;helm dep update&#39; before installing or upgrading the chart, the chart dependencies _must_ be present for this to succeed.
  , v1HelmReleaseSpecChartVersion :: !(Maybe Text) -- ^ "version" - Version is the targeted Helm chart version, e.g. 7.0.1.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecChart
instance A.FromJSON V1HelmReleaseSpecChart where
  parseJSON = A.withObject "V1HelmReleaseSpecChart" $ \o ->
    V1HelmReleaseSpecChart
      <$> (o .:? "chartPullSecret")
      <*> (o .:? "git")
      <*> (o .:? "name")
      <*> (o .:? "path")
      <*> (o .:? "ref")
      <*> (o .:? "repository")
      <*> (o .:? "secretRef")
      <*> (o .:? "skipDepUpdate")
      <*> (o .:? "version")

-- | ToJSON V1HelmReleaseSpecChart
instance A.ToJSON V1HelmReleaseSpecChart where
  toJSON V1HelmReleaseSpecChart {..} =
   _omitNulls
      [ "chartPullSecret" .= v1HelmReleaseSpecChartChartPullSecret
      , "git" .= v1HelmReleaseSpecChartGit
      , "name" .= v1HelmReleaseSpecChartName
      , "path" .= v1HelmReleaseSpecChartPath
      , "ref" .= v1HelmReleaseSpecChartRef
      , "repository" .= v1HelmReleaseSpecChartRepository
      , "secretRef" .= v1HelmReleaseSpecChartSecretRef
      , "skipDepUpdate" .= v1HelmReleaseSpecChartSkipDepUpdate
      , "version" .= v1HelmReleaseSpecChartVersion
      ]


-- | Construct a value of type 'V1HelmReleaseSpecChart' (by applying it's required fields, if any)
mkV1HelmReleaseSpecChart
  :: V1HelmReleaseSpecChart
mkV1HelmReleaseSpecChart =
  V1HelmReleaseSpecChart
  { v1HelmReleaseSpecChartChartPullSecret = Nothing
  , v1HelmReleaseSpecChartGit = Nothing
  , v1HelmReleaseSpecChartName = Nothing
  , v1HelmReleaseSpecChartPath = Nothing
  , v1HelmReleaseSpecChartRef = Nothing
  , v1HelmReleaseSpecChartRepository = Nothing
  , v1HelmReleaseSpecChartSecretRef = Nothing
  , v1HelmReleaseSpecChartSkipDepUpdate = Nothing
  , v1HelmReleaseSpecChartVersion = Nothing
  }

-- ** V1HelmReleaseSpecChartChartPullSecret
-- | V1HelmReleaseSpecChartChartPullSecret
-- ChartPullSecret holds the reference to the authentication secret for accessing the Helm repository using HTTPS basic auth. NOT IMPLEMENTED!
data V1HelmReleaseSpecChartChartPullSecret = V1HelmReleaseSpecChartChartPullSecret
  { v1HelmReleaseSpecChartChartPullSecretName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecChartChartPullSecret
instance A.FromJSON V1HelmReleaseSpecChartChartPullSecret where
  parseJSON = A.withObject "V1HelmReleaseSpecChartChartPullSecret" $ \o ->
    V1HelmReleaseSpecChartChartPullSecret
      <$> (o .:  "name")

-- | ToJSON V1HelmReleaseSpecChartChartPullSecret
instance A.ToJSON V1HelmReleaseSpecChartChartPullSecret where
  toJSON V1HelmReleaseSpecChartChartPullSecret {..} =
   _omitNulls
      [ "name" .= v1HelmReleaseSpecChartChartPullSecretName
      ]


-- | Construct a value of type 'V1HelmReleaseSpecChartChartPullSecret' (by applying it's required fields, if any)
mkV1HelmReleaseSpecChartChartPullSecret
  :: Text -- ^ 'v1HelmReleaseSpecChartChartPullSecretName' 
  -> V1HelmReleaseSpecChartChartPullSecret
mkV1HelmReleaseSpecChartChartPullSecret v1HelmReleaseSpecChartChartPullSecretName =
  V1HelmReleaseSpecChartChartPullSecret
  { v1HelmReleaseSpecChartChartPullSecretName
  }

-- ** V1HelmReleaseSpecChartFileRef
-- | V1HelmReleaseSpecChartFileRef
-- The reference to a local chart file with release values.
data V1HelmReleaseSpecChartFileRef = V1HelmReleaseSpecChartFileRef
  { v1HelmReleaseSpecChartFileRefOptional :: !(Maybe Bool) -- ^ "optional" - Optional will mark this ChartFileSelector as optional. The result of this are that operations are permitted without the source, due to it e.g. being temporarily unavailable.
  , v1HelmReleaseSpecChartFileRefPath :: !(Text) -- ^ /Required/ "path" - Path is the file path to the source relative to the chart root.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecChartFileRef
instance A.FromJSON V1HelmReleaseSpecChartFileRef where
  parseJSON = A.withObject "V1HelmReleaseSpecChartFileRef" $ \o ->
    V1HelmReleaseSpecChartFileRef
      <$> (o .:? "optional")
      <*> (o .:  "path")

-- | ToJSON V1HelmReleaseSpecChartFileRef
instance A.ToJSON V1HelmReleaseSpecChartFileRef where
  toJSON V1HelmReleaseSpecChartFileRef {..} =
   _omitNulls
      [ "optional" .= v1HelmReleaseSpecChartFileRefOptional
      , "path" .= v1HelmReleaseSpecChartFileRefPath
      ]


-- | Construct a value of type 'V1HelmReleaseSpecChartFileRef' (by applying it's required fields, if any)
mkV1HelmReleaseSpecChartFileRef
  :: Text -- ^ 'v1HelmReleaseSpecChartFileRefPath': Path is the file path to the source relative to the chart root.
  -> V1HelmReleaseSpecChartFileRef
mkV1HelmReleaseSpecChartFileRef v1HelmReleaseSpecChartFileRefPath =
  V1HelmReleaseSpecChartFileRef
  { v1HelmReleaseSpecChartFileRefOptional = Nothing
  , v1HelmReleaseSpecChartFileRefPath
  }

-- ** V1HelmReleaseSpecChartSecretRef
-- | V1HelmReleaseSpecChartSecretRef
-- SecretRef holds the authentication secret for accessing the Git repository (over HTTPS). The credentials will be added to an HTTPS GitURL before the mirror is started.
data V1HelmReleaseSpecChartSecretRef = V1HelmReleaseSpecChartSecretRef
  { v1HelmReleaseSpecChartSecretRefName :: !(Text) -- ^ /Required/ "name"
  , v1HelmReleaseSpecChartSecretRefNamespace :: !(Maybe Text) -- ^ "namespace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecChartSecretRef
instance A.FromJSON V1HelmReleaseSpecChartSecretRef where
  parseJSON = A.withObject "V1HelmReleaseSpecChartSecretRef" $ \o ->
    V1HelmReleaseSpecChartSecretRef
      <$> (o .:  "name")
      <*> (o .:? "namespace")

-- | ToJSON V1HelmReleaseSpecChartSecretRef
instance A.ToJSON V1HelmReleaseSpecChartSecretRef where
  toJSON V1HelmReleaseSpecChartSecretRef {..} =
   _omitNulls
      [ "name" .= v1HelmReleaseSpecChartSecretRefName
      , "namespace" .= v1HelmReleaseSpecChartSecretRefNamespace
      ]


-- | Construct a value of type 'V1HelmReleaseSpecChartSecretRef' (by applying it's required fields, if any)
mkV1HelmReleaseSpecChartSecretRef
  :: Text -- ^ 'v1HelmReleaseSpecChartSecretRefName' 
  -> V1HelmReleaseSpecChartSecretRef
mkV1HelmReleaseSpecChartSecretRef v1HelmReleaseSpecChartSecretRefName =
  V1HelmReleaseSpecChartSecretRef
  { v1HelmReleaseSpecChartSecretRefName
  , v1HelmReleaseSpecChartSecretRefNamespace = Nothing
  }

-- ** V1HelmReleaseSpecConfigMapKeyRef
-- | V1HelmReleaseSpecConfigMapKeyRef
-- The reference to a config map with release values.
data V1HelmReleaseSpecConfigMapKeyRef = V1HelmReleaseSpecConfigMapKeyRef
  { v1HelmReleaseSpecConfigMapKeyRefKey :: !(Maybe Text) -- ^ "key"
  , v1HelmReleaseSpecConfigMapKeyRefName :: !(Text) -- ^ /Required/ "name"
  , v1HelmReleaseSpecConfigMapKeyRefNamespace :: !(Maybe Text) -- ^ "namespace"
  , v1HelmReleaseSpecConfigMapKeyRefOptional :: !(Maybe Bool) -- ^ "optional"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecConfigMapKeyRef
instance A.FromJSON V1HelmReleaseSpecConfigMapKeyRef where
  parseJSON = A.withObject "V1HelmReleaseSpecConfigMapKeyRef" $ \o ->
    V1HelmReleaseSpecConfigMapKeyRef
      <$> (o .:? "key")
      <*> (o .:  "name")
      <*> (o .:? "namespace")
      <*> (o .:? "optional")

-- | ToJSON V1HelmReleaseSpecConfigMapKeyRef
instance A.ToJSON V1HelmReleaseSpecConfigMapKeyRef where
  toJSON V1HelmReleaseSpecConfigMapKeyRef {..} =
   _omitNulls
      [ "key" .= v1HelmReleaseSpecConfigMapKeyRefKey
      , "name" .= v1HelmReleaseSpecConfigMapKeyRefName
      , "namespace" .= v1HelmReleaseSpecConfigMapKeyRefNamespace
      , "optional" .= v1HelmReleaseSpecConfigMapKeyRefOptional
      ]


-- | Construct a value of type 'V1HelmReleaseSpecConfigMapKeyRef' (by applying it's required fields, if any)
mkV1HelmReleaseSpecConfigMapKeyRef
  :: Text -- ^ 'v1HelmReleaseSpecConfigMapKeyRefName' 
  -> V1HelmReleaseSpecConfigMapKeyRef
mkV1HelmReleaseSpecConfigMapKeyRef v1HelmReleaseSpecConfigMapKeyRefName =
  V1HelmReleaseSpecConfigMapKeyRef
  { v1HelmReleaseSpecConfigMapKeyRefKey = Nothing
  , v1HelmReleaseSpecConfigMapKeyRefName
  , v1HelmReleaseSpecConfigMapKeyRefNamespace = Nothing
  , v1HelmReleaseSpecConfigMapKeyRefOptional = Nothing
  }

-- ** V1HelmReleaseSpecExternalSourceRef
-- | V1HelmReleaseSpecExternalSourceRef
-- The reference to an external source with release values.
data V1HelmReleaseSpecExternalSourceRef = V1HelmReleaseSpecExternalSourceRef
  { v1HelmReleaseSpecExternalSourceRefOptional :: !(Maybe Bool) -- ^ "optional" - Optional will mark this ExternalSourceSelector as optional. The result of this are that operations are permitted without the source, due to it e.g. being temporarily unavailable.
  , v1HelmReleaseSpecExternalSourceRefUrl :: !(Text) -- ^ /Required/ "url" - URL is the URL of the external source.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecExternalSourceRef
instance A.FromJSON V1HelmReleaseSpecExternalSourceRef where
  parseJSON = A.withObject "V1HelmReleaseSpecExternalSourceRef" $ \o ->
    V1HelmReleaseSpecExternalSourceRef
      <$> (o .:? "optional")
      <*> (o .:  "url")

-- | ToJSON V1HelmReleaseSpecExternalSourceRef
instance A.ToJSON V1HelmReleaseSpecExternalSourceRef where
  toJSON V1HelmReleaseSpecExternalSourceRef {..} =
   _omitNulls
      [ "optional" .= v1HelmReleaseSpecExternalSourceRefOptional
      , "url" .= v1HelmReleaseSpecExternalSourceRefUrl
      ]


-- | Construct a value of type 'V1HelmReleaseSpecExternalSourceRef' (by applying it's required fields, if any)
mkV1HelmReleaseSpecExternalSourceRef
  :: Text -- ^ 'v1HelmReleaseSpecExternalSourceRefUrl': URL is the URL of the external source.
  -> V1HelmReleaseSpecExternalSourceRef
mkV1HelmReleaseSpecExternalSourceRef v1HelmReleaseSpecExternalSourceRefUrl =
  V1HelmReleaseSpecExternalSourceRef
  { v1HelmReleaseSpecExternalSourceRefOptional = Nothing
  , v1HelmReleaseSpecExternalSourceRefUrl
  }

-- ** V1HelmReleaseSpecRollback
-- | V1HelmReleaseSpecRollback
-- The rollback settings for this Helm release.
data V1HelmReleaseSpecRollback = V1HelmReleaseSpecRollback
  { v1HelmReleaseSpecRollbackDisableHooks :: !(Maybe Bool) -- ^ "disableHooks" - DisableHooks will mark this Helm release to prevent hooks from running during the rollback.
  , v1HelmReleaseSpecRollbackEnable :: !(Maybe Bool) -- ^ "enable" - Enable will mark this Helm release for rollbacks.
  , v1HelmReleaseSpecRollbackForce :: !(Maybe Bool) -- ^ "force" - Force will mark this Helm release to &#x60;--force&#x60; rollbacks. This forces the resource updates through delete/recreate if needed.
  , v1HelmReleaseSpecRollbackMaxRetries :: !(Maybe Integer) -- ^ "maxRetries" - MaxRetries is the maximum amount of upgrade retries the operator should make before bailing.
  , v1HelmReleaseSpecRollbackRecreate :: !(Maybe Bool) -- ^ "recreate" - Recreate will mark this Helm release to &#x60;--recreate-pods&#x60; for if applicable. This performs pod restarts.
  , v1HelmReleaseSpecRollbackRetry :: !(Maybe Bool) -- ^ "retry" - Retry will mark this Helm release for upgrade retries after a rollback.
  , v1HelmReleaseSpecRollbackTimeout :: !(Maybe Integer) -- ^ "timeout" - Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during rollback.
  , v1HelmReleaseSpecRollbackWait :: !(Maybe Bool) -- ^ "wait" - Wait will mark this Helm release to wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecRollback
instance A.FromJSON V1HelmReleaseSpecRollback where
  parseJSON = A.withObject "V1HelmReleaseSpecRollback" $ \o ->
    V1HelmReleaseSpecRollback
      <$> (o .:? "disableHooks")
      <*> (o .:? "enable")
      <*> (o .:? "force")
      <*> (o .:? "maxRetries")
      <*> (o .:? "recreate")
      <*> (o .:? "retry")
      <*> (o .:? "timeout")
      <*> (o .:? "wait")

-- | ToJSON V1HelmReleaseSpecRollback
instance A.ToJSON V1HelmReleaseSpecRollback where
  toJSON V1HelmReleaseSpecRollback {..} =
   _omitNulls
      [ "disableHooks" .= v1HelmReleaseSpecRollbackDisableHooks
      , "enable" .= v1HelmReleaseSpecRollbackEnable
      , "force" .= v1HelmReleaseSpecRollbackForce
      , "maxRetries" .= v1HelmReleaseSpecRollbackMaxRetries
      , "recreate" .= v1HelmReleaseSpecRollbackRecreate
      , "retry" .= v1HelmReleaseSpecRollbackRetry
      , "timeout" .= v1HelmReleaseSpecRollbackTimeout
      , "wait" .= v1HelmReleaseSpecRollbackWait
      ]


-- | Construct a value of type 'V1HelmReleaseSpecRollback' (by applying it's required fields, if any)
mkV1HelmReleaseSpecRollback
  :: V1HelmReleaseSpecRollback
mkV1HelmReleaseSpecRollback =
  V1HelmReleaseSpecRollback
  { v1HelmReleaseSpecRollbackDisableHooks = Nothing
  , v1HelmReleaseSpecRollbackEnable = Nothing
  , v1HelmReleaseSpecRollbackForce = Nothing
  , v1HelmReleaseSpecRollbackMaxRetries = Nothing
  , v1HelmReleaseSpecRollbackRecreate = Nothing
  , v1HelmReleaseSpecRollbackRetry = Nothing
  , v1HelmReleaseSpecRollbackTimeout = Nothing
  , v1HelmReleaseSpecRollbackWait = Nothing
  }

-- ** V1HelmReleaseSpecSecretKeyRef
-- | V1HelmReleaseSpecSecretKeyRef
-- The reference to a secret with release values.
data V1HelmReleaseSpecSecretKeyRef = V1HelmReleaseSpecSecretKeyRef
  { v1HelmReleaseSpecSecretKeyRefKey :: !(Maybe Text) -- ^ "key"
  , v1HelmReleaseSpecSecretKeyRefName :: !(Text) -- ^ /Required/ "name"
  , v1HelmReleaseSpecSecretKeyRefNamespace :: !(Maybe Text) -- ^ "namespace"
  , v1HelmReleaseSpecSecretKeyRefOptional :: !(Maybe Bool) -- ^ "optional"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecSecretKeyRef
instance A.FromJSON V1HelmReleaseSpecSecretKeyRef where
  parseJSON = A.withObject "V1HelmReleaseSpecSecretKeyRef" $ \o ->
    V1HelmReleaseSpecSecretKeyRef
      <$> (o .:? "key")
      <*> (o .:  "name")
      <*> (o .:? "namespace")
      <*> (o .:? "optional")

-- | ToJSON V1HelmReleaseSpecSecretKeyRef
instance A.ToJSON V1HelmReleaseSpecSecretKeyRef where
  toJSON V1HelmReleaseSpecSecretKeyRef {..} =
   _omitNulls
      [ "key" .= v1HelmReleaseSpecSecretKeyRefKey
      , "name" .= v1HelmReleaseSpecSecretKeyRefName
      , "namespace" .= v1HelmReleaseSpecSecretKeyRefNamespace
      , "optional" .= v1HelmReleaseSpecSecretKeyRefOptional
      ]


-- | Construct a value of type 'V1HelmReleaseSpecSecretKeyRef' (by applying it's required fields, if any)
mkV1HelmReleaseSpecSecretKeyRef
  :: Text -- ^ 'v1HelmReleaseSpecSecretKeyRefName' 
  -> V1HelmReleaseSpecSecretKeyRef
mkV1HelmReleaseSpecSecretKeyRef v1HelmReleaseSpecSecretKeyRefName =
  V1HelmReleaseSpecSecretKeyRef
  { v1HelmReleaseSpecSecretKeyRefKey = Nothing
  , v1HelmReleaseSpecSecretKeyRefName
  , v1HelmReleaseSpecSecretKeyRefNamespace = Nothing
  , v1HelmReleaseSpecSecretKeyRefOptional = Nothing
  }

-- ** V1HelmReleaseSpecTest
-- | V1HelmReleaseSpecTest
-- The test settings for this Helm release.
data V1HelmReleaseSpecTest = V1HelmReleaseSpecTest
  { v1HelmReleaseSpecTestCleanup :: !(Maybe Bool) -- ^ "cleanup" - Cleanup, when targeting Helm 2, determines whether to delete test pods between each test run initiated by the Helm Operator.
  , v1HelmReleaseSpecTestEnable :: !(Maybe Bool) -- ^ "enable" - Enable will mark this Helm release for tests.
  , v1HelmReleaseSpecTestIgnoreFailures :: !(Maybe Bool) -- ^ "ignoreFailures" - IgnoreFailures will cause a Helm release to be rolled back if it fails otherwise it will be left in a released state
  , v1HelmReleaseSpecTestTimeout :: !(Maybe Integer) -- ^ "timeout" - Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during test.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecTest
instance A.FromJSON V1HelmReleaseSpecTest where
  parseJSON = A.withObject "V1HelmReleaseSpecTest" $ \o ->
    V1HelmReleaseSpecTest
      <$> (o .:? "cleanup")
      <*> (o .:? "enable")
      <*> (o .:? "ignoreFailures")
      <*> (o .:? "timeout")

-- | ToJSON V1HelmReleaseSpecTest
instance A.ToJSON V1HelmReleaseSpecTest where
  toJSON V1HelmReleaseSpecTest {..} =
   _omitNulls
      [ "cleanup" .= v1HelmReleaseSpecTestCleanup
      , "enable" .= v1HelmReleaseSpecTestEnable
      , "ignoreFailures" .= v1HelmReleaseSpecTestIgnoreFailures
      , "timeout" .= v1HelmReleaseSpecTestTimeout
      ]


-- | Construct a value of type 'V1HelmReleaseSpecTest' (by applying it's required fields, if any)
mkV1HelmReleaseSpecTest
  :: V1HelmReleaseSpecTest
mkV1HelmReleaseSpecTest =
  V1HelmReleaseSpecTest
  { v1HelmReleaseSpecTestCleanup = Nothing
  , v1HelmReleaseSpecTestEnable = Nothing
  , v1HelmReleaseSpecTestIgnoreFailures = Nothing
  , v1HelmReleaseSpecTestTimeout = Nothing
  }

-- ** V1HelmReleaseSpecValueFileSecrets
-- | V1HelmReleaseSpecValueFileSecrets
data V1HelmReleaseSpecValueFileSecrets = V1HelmReleaseSpecValueFileSecrets
  { v1HelmReleaseSpecValueFileSecretsName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecValueFileSecrets
instance A.FromJSON V1HelmReleaseSpecValueFileSecrets where
  parseJSON = A.withObject "V1HelmReleaseSpecValueFileSecrets" $ \o ->
    V1HelmReleaseSpecValueFileSecrets
      <$> (o .:  "name")

-- | ToJSON V1HelmReleaseSpecValueFileSecrets
instance A.ToJSON V1HelmReleaseSpecValueFileSecrets where
  toJSON V1HelmReleaseSpecValueFileSecrets {..} =
   _omitNulls
      [ "name" .= v1HelmReleaseSpecValueFileSecretsName
      ]


-- | Construct a value of type 'V1HelmReleaseSpecValueFileSecrets' (by applying it's required fields, if any)
mkV1HelmReleaseSpecValueFileSecrets
  :: Text -- ^ 'v1HelmReleaseSpecValueFileSecretsName' 
  -> V1HelmReleaseSpecValueFileSecrets
mkV1HelmReleaseSpecValueFileSecrets v1HelmReleaseSpecValueFileSecretsName =
  V1HelmReleaseSpecValueFileSecrets
  { v1HelmReleaseSpecValueFileSecretsName
  }

-- ** V1HelmReleaseSpecValuesFrom
-- | V1HelmReleaseSpecValuesFrom
data V1HelmReleaseSpecValuesFrom = V1HelmReleaseSpecValuesFrom
  { v1HelmReleaseSpecValuesFromChartFileRef :: !(Maybe V1HelmReleaseSpecChartFileRef) -- ^ "chartFileRef"
  , v1HelmReleaseSpecValuesFromConfigMapKeyRef :: !(Maybe V1HelmReleaseSpecConfigMapKeyRef) -- ^ "configMapKeyRef"
  , v1HelmReleaseSpecValuesFromExternalSourceRef :: !(Maybe V1HelmReleaseSpecExternalSourceRef) -- ^ "externalSourceRef"
  , v1HelmReleaseSpecValuesFromSecretKeyRef :: !(Maybe V1HelmReleaseSpecSecretKeyRef) -- ^ "secretKeyRef"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseSpecValuesFrom
instance A.FromJSON V1HelmReleaseSpecValuesFrom where
  parseJSON = A.withObject "V1HelmReleaseSpecValuesFrom" $ \o ->
    V1HelmReleaseSpecValuesFrom
      <$> (o .:? "chartFileRef")
      <*> (o .:? "configMapKeyRef")
      <*> (o .:? "externalSourceRef")
      <*> (o .:? "secretKeyRef")

-- | ToJSON V1HelmReleaseSpecValuesFrom
instance A.ToJSON V1HelmReleaseSpecValuesFrom where
  toJSON V1HelmReleaseSpecValuesFrom {..} =
   _omitNulls
      [ "chartFileRef" .= v1HelmReleaseSpecValuesFromChartFileRef
      , "configMapKeyRef" .= v1HelmReleaseSpecValuesFromConfigMapKeyRef
      , "externalSourceRef" .= v1HelmReleaseSpecValuesFromExternalSourceRef
      , "secretKeyRef" .= v1HelmReleaseSpecValuesFromSecretKeyRef
      ]


-- | Construct a value of type 'V1HelmReleaseSpecValuesFrom' (by applying it's required fields, if any)
mkV1HelmReleaseSpecValuesFrom
  :: V1HelmReleaseSpecValuesFrom
mkV1HelmReleaseSpecValuesFrom =
  V1HelmReleaseSpecValuesFrom
  { v1HelmReleaseSpecValuesFromChartFileRef = Nothing
  , v1HelmReleaseSpecValuesFromConfigMapKeyRef = Nothing
  , v1HelmReleaseSpecValuesFromExternalSourceRef = Nothing
  , v1HelmReleaseSpecValuesFromSecretKeyRef = Nothing
  }

-- ** V1HelmReleaseStatus
-- | V1HelmReleaseStatus
-- HelmReleaseStatus contains status information about an HelmRelease.
data V1HelmReleaseStatus = V1HelmReleaseStatus
  { v1HelmReleaseStatusConditions :: !(Maybe [V1HelmReleaseStatusConditions]) -- ^ "conditions" - Conditions contains observations of the resource&#39;s state, e.g., has the chart which it refers to been fetched.
  , v1HelmReleaseStatusLastAttemptedRevision :: !(Maybe Text) -- ^ "lastAttemptedRevision" - LastAttemptedRevision is the revision of the latest chart sync, and may be of a failed release.
  , v1HelmReleaseStatusObservedGeneration :: !(Maybe Integer) -- ^ "observedGeneration" - ObservedGeneration is the most recent generation observed by the operator.
  , v1HelmReleaseStatusPhase :: !(Maybe E'Phase) -- ^ "phase" - Phase the release is in, one of (&#39;ChartFetched&#39;, &#39;ChartFetchFailed&#39;, &#39;Installing&#39;, &#39;Upgrading&#39;, &#39;Deployed&#39;, &#39;DeployFailed&#39;, &#39;Testing&#39;, &#39;TestFailed&#39;, &#39;Tested&#39;, &#39;Succeeded&#39;, &#39;RollingBack&#39;, &#39;RolledBack&#39;, &#39;RollbackFailed&#39;)
  , v1HelmReleaseStatusReleaseName :: !(Maybe Text) -- ^ "releaseName" - ReleaseName is the name as either supplied or generated.
  , v1HelmReleaseStatusReleaseStatus :: !(Maybe Text) -- ^ "releaseStatus" - ReleaseStatus is the status as given by Helm for the release managed by this resource.
  , v1HelmReleaseStatusRevision :: !(Maybe Text) -- ^ "revision" - Revision holds the Git hash or version of the chart currently deployed.
  , v1HelmReleaseStatusRollbackCount :: !(Maybe Integer) -- ^ "rollbackCount" - RollbackCount records the amount of rollback attempts made, it is incremented after a rollback failure and reset after a successful upgrade or revision change.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseStatus
instance A.FromJSON V1HelmReleaseStatus where
  parseJSON = A.withObject "V1HelmReleaseStatus" $ \o ->
    V1HelmReleaseStatus
      <$> (o .:? "conditions")
      <*> (o .:? "lastAttemptedRevision")
      <*> (o .:? "observedGeneration")
      <*> (o .:? "phase")
      <*> (o .:? "releaseName")
      <*> (o .:? "releaseStatus")
      <*> (o .:? "revision")
      <*> (o .:? "rollbackCount")

-- | ToJSON V1HelmReleaseStatus
instance A.ToJSON V1HelmReleaseStatus where
  toJSON V1HelmReleaseStatus {..} =
   _omitNulls
      [ "conditions" .= v1HelmReleaseStatusConditions
      , "lastAttemptedRevision" .= v1HelmReleaseStatusLastAttemptedRevision
      , "observedGeneration" .= v1HelmReleaseStatusObservedGeneration
      , "phase" .= v1HelmReleaseStatusPhase
      , "releaseName" .= v1HelmReleaseStatusReleaseName
      , "releaseStatus" .= v1HelmReleaseStatusReleaseStatus
      , "revision" .= v1HelmReleaseStatusRevision
      , "rollbackCount" .= v1HelmReleaseStatusRollbackCount
      ]


-- | Construct a value of type 'V1HelmReleaseStatus' (by applying it's required fields, if any)
mkV1HelmReleaseStatus
  :: V1HelmReleaseStatus
mkV1HelmReleaseStatus =
  V1HelmReleaseStatus
  { v1HelmReleaseStatusConditions = Nothing
  , v1HelmReleaseStatusLastAttemptedRevision = Nothing
  , v1HelmReleaseStatusObservedGeneration = Nothing
  , v1HelmReleaseStatusPhase = Nothing
  , v1HelmReleaseStatusReleaseName = Nothing
  , v1HelmReleaseStatusReleaseStatus = Nothing
  , v1HelmReleaseStatusRevision = Nothing
  , v1HelmReleaseStatusRollbackCount = Nothing
  }

-- ** V1HelmReleaseStatusConditions
-- | V1HelmReleaseStatusConditions
data V1HelmReleaseStatusConditions = V1HelmReleaseStatusConditions
  { v1HelmReleaseStatusConditionsLastTransitionTime :: !(Maybe DateTime) -- ^ "lastTransitionTime" - LastTransitionTime is the timestamp corresponding to the last status change of this condition.
  , v1HelmReleaseStatusConditionsLastUpdateTime :: !(Maybe DateTime) -- ^ "lastUpdateTime" - LastUpdateTime is the timestamp corresponding to the last status update of this condition.
  , v1HelmReleaseStatusConditionsMessage :: !(Maybe Text) -- ^ "message" - Message is a human readable description of the details of the last transition, complementing reason.
  , v1HelmReleaseStatusConditionsReason :: !(Maybe Text) -- ^ "reason" - Reason is a brief machine readable explanation for the condition&#39;s last transition.
  , v1HelmReleaseStatusConditionsStatus :: !(E'Status) -- ^ /Required/ "status" - Status of the condition, one of (&#39;True&#39;, &#39;False&#39;, &#39;Unknown&#39;).
  , v1HelmReleaseStatusConditionsType :: !(E'Type) -- ^ /Required/ "type" - Type of the condition, one of (&#39;ChartFetched&#39;, &#39;Deployed&#39;, &#39;Released&#39;, &#39;RolledBack&#39;, &#39;Tested&#39;).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1HelmReleaseStatusConditions
instance A.FromJSON V1HelmReleaseStatusConditions where
  parseJSON = A.withObject "V1HelmReleaseStatusConditions" $ \o ->
    V1HelmReleaseStatusConditions
      <$> (o .:? "lastTransitionTime")
      <*> (o .:? "lastUpdateTime")
      <*> (o .:? "message")
      <*> (o .:? "reason")
      <*> (o .:  "status")
      <*> (o .:  "type")

-- | ToJSON V1HelmReleaseStatusConditions
instance A.ToJSON V1HelmReleaseStatusConditions where
  toJSON V1HelmReleaseStatusConditions {..} =
   _omitNulls
      [ "lastTransitionTime" .= v1HelmReleaseStatusConditionsLastTransitionTime
      , "lastUpdateTime" .= v1HelmReleaseStatusConditionsLastUpdateTime
      , "message" .= v1HelmReleaseStatusConditionsMessage
      , "reason" .= v1HelmReleaseStatusConditionsReason
      , "status" .= v1HelmReleaseStatusConditionsStatus
      , "type" .= v1HelmReleaseStatusConditionsType
      ]


-- | Construct a value of type 'V1HelmReleaseStatusConditions' (by applying it's required fields, if any)
mkV1HelmReleaseStatusConditions
  :: E'Status -- ^ 'v1HelmReleaseStatusConditionsStatus': Status of the condition, one of ('True', 'False', 'Unknown').
  -> E'Type -- ^ 'v1HelmReleaseStatusConditionsType': Type of the condition, one of ('ChartFetched', 'Deployed', 'Released', 'RolledBack', 'Tested').
  -> V1HelmReleaseStatusConditions
mkV1HelmReleaseStatusConditions v1HelmReleaseStatusConditionsStatus v1HelmReleaseStatusConditionsType =
  V1HelmReleaseStatusConditions
  { v1HelmReleaseStatusConditionsLastTransitionTime = Nothing
  , v1HelmReleaseStatusConditionsLastUpdateTime = Nothing
  , v1HelmReleaseStatusConditionsMessage = Nothing
  , v1HelmReleaseStatusConditionsReason = Nothing
  , v1HelmReleaseStatusConditionsStatus
  , v1HelmReleaseStatusConditionsType
  }


-- * Enums


-- ** E'HelmVersion

-- | Enum of 'Text' . 
-- HelmVersion is the version of Helm to target. If not supplied, the lowest _enabled Helm version_ will be targeted. Valid HelmVersion values are: \"v2\", \"v3\"
data E'HelmVersion
  = E'HelmVersion'V2 -- ^ @"v2"@
  | E'HelmVersion'V3 -- ^ @"v3"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'HelmVersion where toJSON = A.toJSON . fromE'HelmVersion
instance A.FromJSON E'HelmVersion where parseJSON o = P.either P.fail (pure . P.id) . toE'HelmVersion =<< A.parseJSON o
instance WH.ToHttpApiData E'HelmVersion where toQueryParam = WH.toQueryParam . fromE'HelmVersion
instance WH.FromHttpApiData E'HelmVersion where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'HelmVersion
instance MimeRender MimeMultipartFormData E'HelmVersion where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'HelmVersion' enum
fromE'HelmVersion :: E'HelmVersion -> Text
fromE'HelmVersion = \case
  E'HelmVersion'V2 -> "v2"
  E'HelmVersion'V3 -> "v3"

-- | parse 'E'HelmVersion' enum
toE'HelmVersion :: Text -> P.Either String E'HelmVersion
toE'HelmVersion = \case
  "v2" -> P.Right E'HelmVersion'V2
  "v3" -> P.Right E'HelmVersion'V3
  s -> P.Left $ "toE'HelmVersion: enum parse failure: " P.++ P.show s


-- ** E'Phase

-- | Enum of 'Text' . 
-- Phase the release is in, one of ('ChartFetched', 'ChartFetchFailed', 'Installing', 'Upgrading', 'Deployed', 'DeployFailed', 'Testing', 'TestFailed', 'Tested', 'Succeeded', 'RollingBack', 'RolledBack', 'RollbackFailed')
data E'Phase
  = E'Phase'ChartFetched -- ^ @"ChartFetched"@
  | E'Phase'ChartFetchFailed -- ^ @"ChartFetchFailed"@
  | E'Phase'Installing -- ^ @"Installing"@
  | E'Phase'Upgrading -- ^ @"Upgrading"@
  | E'Phase'Deployed -- ^ @"Deployed"@
  | E'Phase'DeployFailed -- ^ @"DeployFailed"@
  | E'Phase'Testing -- ^ @"Testing"@
  | E'Phase'TestFailed -- ^ @"TestFailed"@
  | E'Phase'Tested -- ^ @"Tested"@
  | E'Phase'Succeeded -- ^ @"Succeeded"@
  | E'Phase'Failed -- ^ @"Failed"@
  | E'Phase'RollingBack -- ^ @"RollingBack"@
  | E'Phase'RolledBack -- ^ @"RolledBack"@
  | E'Phase'RollbackFailed -- ^ @"RollbackFailed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Phase where toJSON = A.toJSON . fromE'Phase
instance A.FromJSON E'Phase where parseJSON o = P.either P.fail (pure . P.id) . toE'Phase =<< A.parseJSON o
instance WH.ToHttpApiData E'Phase where toQueryParam = WH.toQueryParam . fromE'Phase
instance WH.FromHttpApiData E'Phase where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Phase
instance MimeRender MimeMultipartFormData E'Phase where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Phase' enum
fromE'Phase :: E'Phase -> Text
fromE'Phase = \case
  E'Phase'ChartFetched -> "ChartFetched"
  E'Phase'ChartFetchFailed -> "ChartFetchFailed"
  E'Phase'Installing -> "Installing"
  E'Phase'Upgrading -> "Upgrading"
  E'Phase'Deployed -> "Deployed"
  E'Phase'DeployFailed -> "DeployFailed"
  E'Phase'Testing -> "Testing"
  E'Phase'TestFailed -> "TestFailed"
  E'Phase'Tested -> "Tested"
  E'Phase'Succeeded -> "Succeeded"
  E'Phase'Failed -> "Failed"
  E'Phase'RollingBack -> "RollingBack"
  E'Phase'RolledBack -> "RolledBack"
  E'Phase'RollbackFailed -> "RollbackFailed"

-- | parse 'E'Phase' enum
toE'Phase :: Text -> P.Either String E'Phase
toE'Phase = \case
  "ChartFetched" -> P.Right E'Phase'ChartFetched
  "ChartFetchFailed" -> P.Right E'Phase'ChartFetchFailed
  "Installing" -> P.Right E'Phase'Installing
  "Upgrading" -> P.Right E'Phase'Upgrading
  "Deployed" -> P.Right E'Phase'Deployed
  "DeployFailed" -> P.Right E'Phase'DeployFailed
  "Testing" -> P.Right E'Phase'Testing
  "TestFailed" -> P.Right E'Phase'TestFailed
  "Tested" -> P.Right E'Phase'Tested
  "Succeeded" -> P.Right E'Phase'Succeeded
  "Failed" -> P.Right E'Phase'Failed
  "RollingBack" -> P.Right E'Phase'RollingBack
  "RolledBack" -> P.Right E'Phase'RolledBack
  "RollbackFailed" -> P.Right E'Phase'RollbackFailed
  s -> P.Left $ "toE'Phase: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' . 
-- Status of the condition, one of ('True', 'False', 'Unknown').
data E'Status
  = E'Status'True -- ^ @"True"@
  | E'Status'False -- ^ @"False"@
  | E'Status'Unknown -- ^ @"Unknown"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'True -> "True"
  E'Status'False -> "False"
  E'Status'Unknown -> "Unknown"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "True" -> P.Right E'Status'True
  "False" -> P.Right E'Status'False
  "Unknown" -> P.Right E'Status'Unknown
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' . 
-- Type of the condition, one of ('ChartFetched', 'Deployed', 'Released', 'RolledBack', 'Tested').
data E'Type
  = E'Type'ChartFetched -- ^ @"ChartFetched"@
  | E'Type'Deployed -- ^ @"Deployed"@
  | E'Type'Released -- ^ @"Released"@
  | E'Type'RolledBack -- ^ @"RolledBack"@
  | E'Type'Tested -- ^ @"Tested"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'ChartFetched -> "ChartFetched"
  E'Type'Deployed -> "Deployed"
  E'Type'Released -> "Released"
  E'Type'RolledBack -> "RolledBack"
  E'Type'Tested -> "Tested"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "ChartFetched" -> P.Right E'Type'ChartFetched
  "Deployed" -> P.Right E'Type'Deployed
  "Released" -> P.Right E'Type'Released
  "RolledBack" -> P.Right E'Type'RolledBack
  "Tested" -> P.Right E'Type'Tested
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s



